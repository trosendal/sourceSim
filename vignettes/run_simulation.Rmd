---
title: "Running a Bacmeta Simulation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Running a Bacmeta Simulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

In this example, we will be simulating population genetics and evolution of
the seven common "housekeeping genes" in *Campylobacter jejuni*, in three
metapopulations.

Start by loading theSourceSim package:
```{r, echo = TRUE, eval = FALSE}
library(sourceSim)
```

Next we will set some parameters of the simulation specific for
*Campylobacter jejuni*. Sample sequences of the seven housekeeping genes that
are used for 7-allele MLST are built into the package. These were downloaded
from [pubMLST](https://pubmlst.org/). We load those sequences tocalculate the
nucleotide frequencies for *C. jejuni*:

```{r, echo = TRUE, eval = FALSE}
sequences <- internal_sequences("Campylobacter")
bases <- paste(sequences, collapse = "")
frequencies <- base_frequencies(bases)
proa <- frequencies[names(frequencies) == "A"]
prot <- frequencies[names(frequencies) == "T"]
prog <- frequencies[names(frequencies) == "G"]
proc <- frequencies[names(frequencies) == "C"]
```

The number of loci in this case is the length of the **sequences** object
which is 7 since there are 7 sequenced loci. We also define the length
of each allele as 500 and arbitrarily pick 50000 as the number of
bacteria in each of 3 metapopulations. This is used to generate a
random set of individuals in the metapopulations to start the
simulation. These will not reflect the true structure of *C. jejuni*
sequences, only the nucleotide frequencies.

```{r, echo = TRUE, eval = FALSE}
nloc <- length(sequences)

## output filename modifier (must be alphanumeric)
opfn <- 1

## length of each locus
lole <- 500

## Number of bacteria in each population
nbac <- 50000

## The number of populations to simulate
npop <- 3
```

These three metapopulations may interact with one another during the
simulation. The interaction is expressed as a probability of migration
of an individual from one metapopulation to another during one
generation. Here we set the migration rate to 0. Within each
metapopulation, mutation and recombination can occur from one
generation to the next. Here we select appropriate values for
*C.jejuni*:

```{r, echo = TRUE, eval = FALSE}
## Migration rate scaler
migr <- 0

## Migration probability
migp <- 0

## Mutation rate for Campylobacter jejuni
## Estimates from Wilson et al. (2009, Mol Biol Evol)
## https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2639114/
generation_length <- 2.79e-4    # years
gen_per_year <- 1 / generation_length
mutation_rate <- 3.23e-2 # per kilobase per year
mutation_rate <- mutation_rate / 1000 # per base per year
mutation_rate <- mutation_rate / gen_per_year # per base per generation

## Recombination rate relative to mutations.
## Estimate from Yu et al. (2012, J Mol Evol)
## https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3985069/
rr <- 6.96

## Recombination length was determined to be 3000 bases, therefore
## longer than the gene length, so we will set the parameter to 0 to
## indicate the whole allele
rl <- 0
```

Then we set some parameters about how a generation is sampled to move
onto the next and how frequently to write the data out:

```{r, echo = TRUE, eval = FALSE}
## Save initial genome (1 == yes)
iseq <- 1

## Sequence saving: sample size as proportion of population
seqs <- 0.01

## Sequence saving: generation interval
seqi <- 10000

## Collect all the parameters in a named list variable

parameters <- list(
  OPFN = opfn,
  LOLE = lole,
  NLOC = nloc,
  NBAC = nbac,
  NPOP = npop,
  MIGR = migr,
  MIGP = migp,
  MUTR = mutation_rate,
  RECR = rr,
  RECL = rl,
  PROA = proa,
  PROT = prot,
  PROG = prog,
  PROC = proc,
  SEQS = seqs
)
```

Now we can use these parameters to run a simulation of bacterial evolution:


```{r, echo = TRUE, eval = FALSE}
res_1 <- simu(input = parameters)
```

Let's peek at the results:

```{r, echo = TRUE, eval = FALSE}
res_1
```

The resulting data.frame represents the distribution of genotypes in each of
the three metapopulations in the last generation of the simulation. Every row
is one unique genotype that has been produced in the  simulation, with unique
identifiers and its frequency in each metapopulation. A generated MLST name is
also given which does not correspond to the PubMLST nomenclature but is just a
convenient identifier. If you inspect the species you will notice that there is
no overlap between the three metapopulations. This is because shared membership
of a genotype in multiple metapopulations can only arise by random chance
without migration.

## Simulation of bacterial populations with unbalanced migration

In the previous example, we used a constant migration rate of 0,
meaning there was no migration. One can also provide a migration
matrix which specifies the migrations between metapopulations. The
matrix is of dimensions n x n where n is the number of populations,
and the value at position (row<sub>i</sub> , column<sub>j</sub>)
represents the migration rate from population i to population j.

```{r, echo = TRUE, eval = FALSE}
## Define the migration matrix (we have 3 populations)
mig_mat <- matrix(c(0,    0, 0,
                    0.01,  0, 0,
                    0.01, 0, 0),
                  nrow = 3,
                  byrow = TRUE)
```

Let's run the simulation again, this time with a migration matrix and
plotting the results in a phylogenetic graph:

```{r, echo = TRUE, eval = FALSE}
result <- simu(input = parameters, migration = mig_mat)
plot(result)
```
```{r, echo = FALSE, eval = TRUE, fig.width = 7.5, fig.asp = 1}
library(sourceSim)
data(result, package = "sourceSim")
plot(result)
```

## Use data to test a source attribution model

Now you have a simulated set of bacterial populations from 3
artificial populations which a degree of overlap. These might
represent 3 sources of human infection of *Campylobacter*. Now that we
have these populations we can sample from them to generate an
artificial distribution of human isolates based on the relative
contribution of each source to human cases. These should be expressed
as fractions of the total number of human cases, which we assume to be
100. In the next example, we consider that 10% of human cases are due
to contact with population 0, 85% of cases are due to contact with
population 1 and the remaining 5% of human cases are due to
population 3. We can then generate a dataset to submit to a source
attribution model to attempt to find these sampling fractions.

```{r, echo = TRUE, eval = TRUE}
## Which populations do the human cases come from?:
## just keep the populations in the result:
result <- result$population
pops <- table(factor(sample(x= c(1, 2, 3),
                            size = 100,
                            prob = c(0.1, 0.85, 0.05),
                            replace = TRUE),
              levels = c(1, 2, 3)))
## Sample an MLST type for each human cases:
result$Pop_human <- as.numeric(table(factor(do.call("c", lapply(seq_len(length(pops)), function(x) {
    sample(result[, "seqID"],
           pops[x],
           replace = TRUE,
           prob = result[, x])
})), levels = result[, "seqID"])))
```

This new column in the data can then be used to test a source
attribution model. Let's try with the asymmetry island model. The data
needs to be converted to a format that model accepts:

```{r, echo = TRUE, eval = TRUE}
## Just keep what we need
pops <- c("Pop_human", "Pop_0", "Pop_1", "Pop_2")

## expand to long form
result <- do.call("rbind", lapply(pops, function(x) {
    df <- data.frame(pop = x,
                     count = result[, x],
                     MLST = result[, "MLST"],
                     ST = result[, "seqID"])
    do.call("rbind", apply(df, 1, function(x) {
        matrix(c(rep(x[1], x[2]),
                 rep(x[3], x[2]),
                 rep(x[4], x[2])), ncol = 3)
    }))
}))

result <- cbind(result[, c(1, 3)], do.call("rbind", strsplit(result[, 2], "-")))
colnames(result) <- c("group", "ST", "ASP", "GLN", "GLT", "GLY", "PGM", "TKT", "UNC")
result[, "group"] <- as.character(factor(result[, "group"],
                                       levels = pops,
                                       labels = c(0, 1, 2, 3)))
result <- as.data.frame(result)
result <- result[, c(2, 3, 4, 5, 6, 7, 8, 9, 1)]
write.table(result, file = "input.txt", quote = FALSE, row.names = FALSE, sep = "\t")
```

Now if you have the "isource" binary you can run the asymmetric island
model on that data and determine the attribution.

```r, echo = TRUE, eval = FALSE
system("isource input.txt output.txt 10000 5 1 'group'")
```

You should then get the 'output.txt' and 'g_output.txt' files
containing the results of the attribution. We can read them in and
summarize the result:

```r, echo = TRUE, eval = TRUE
mcmc <- read.table("output.txt", header=T, comment.char="")
fmcmc <- read.table("output.txt", header=T, comment.char="")
g<- t(matrix(scan("g_output.txt", what=double(0), sep="\t"), nrow = 3))
sim <- list(mcmc = mcmc, fmcmc = fmcmc, g = g, ng = 3)

## Set the burnin
gd <- sim$mcmc$iter >= 1000
fd <- sim$fmcmc$iter >= 500
df <- sim$fmcmc[fd, 2:(sim$ng+1)]
names(df) <- pops[-1]
pe <- apply(df, 2, function(x) {
    c("mean" = mean(x),
      "median" = median(x),
      "sd" = sd(x),
      quantile(x, c(.025,.975)))
})
pe[1, ]

```
